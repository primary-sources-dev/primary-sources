"""
ocr_worker.py — Background OCR processing for the GUI tool.

Supports two backends:
1. Python (pytesseract + pdf2image) — Windows native
2. WSL (ocrmypdf) — Higher quality, requires WSL Ubuntu

Supported image formats:
- PDF, JPG, PNG, TIFF, WEBP (native PIL)
- HEIC/HEIF (iPhone photos via pillow-heif)
"""

import os
import json
import subprocess
import threading
from pathlib import Path
from typing import Callable, Optional

# Register HEIC/HEIF support for iPhone photos
try:
    from pillow_heif import register_heif_opener
    register_heif_opener()
    HEIC_SUPPORTED = True
except ImportError:
    HEIC_SUPPORTED = False

# Poppler path for Windows (adjust if needed)
POPPLER_PATH = r"C:\Users\willh\AppData\Local\Microsoft\WinGet\Packages\oschwartz10612.Poppler_Microsoft.Winget.Source_8wekyb3d8bbwe\poppler-25.07.0\Library\bin"

HTML_TEMPLATE = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{TITLE}} | Archival Transcript</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700&family=Playfair+Display:ital,wght@0,700;1,700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0f1113;
            --surface: #1a1d20;
            --primary: #c5a67c;
            --text: #d1d5db;
            --text-heading: #e5e7eb;
            --border: rgba(197, 166, 124, 0.2);
        }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Inter', system-ui, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 40px 20px;
            display: flex;
            justify-content: center;
        }

        .container {
            max-width: 800px;
            width: 100%;
        }

        header {
            border-bottom: 2px solid var(--primary);
            padding-bottom: 20px;
            margin-bottom: 40px;
            text-align: center;
        }

        h1 {
            font-family: 'Playfair Display', serif;
            color: var(--primary);
            font-size: 2.5rem;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .metadata {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.6;
            margin-top: 10px;
        }

        section {
            background-color: var(--surface);
            border: 1px solid var(--border);
            padding: 40px;
            margin-bottom: 30px;
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        section::before {
            content: "";
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border: 1px solid rgba(197, 166, 124, 0.05);
            pointer-events: none;
        }

        .page-header {
            font-family: 'Playfair Display', serif;
            color: var(--primary);
            font-size: 0.9rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 5px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
        }

        .content {
            white-space: pre-wrap;
            font-size: 1.05rem;
        }

        footer {
            text-align: center;
            margin-top: 60px;
            font-size: 0.7rem;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        @media print {
            body { background: white; color: black; padding: 0; }
            section { box-shadow: none; border: 1px solid #ddd; page-break-after: always; }
            .container { max-width: 100%; }
            h1 { color: black; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Case File</h1>
            <div class="metadata">Primary Sources Historical Engine | {{FILENAME}}</div>
        </header>
        
        {{CONTENT}}

        <footer>
            Forensic Transcription Generated by Primary Sources v1.0
        </footer>
    </div>
</body>
</html>"""


class OCRWorker:
    """Handles OCR processing in a background thread."""

    def __init__(
        self,
        backend: str = "wsl",
        output_dir: str = ".",
        output_pdf: bool = True,
        output_txt: bool = True,
        output_md: bool = False,
        output_html: bool = False,
        output_json: bool = True,
        deskew: bool = True,
        clean: bool = True,
        force_ocr: bool = False,
        on_progress: Optional[Callable] = None,
        on_complete: Optional[Callable] = None,
        on_log: Optional[Callable[[str], None]] = None,
    ):
        # Configuration (used by process_file)
        self.backend = backend
        self.output_dir = output_dir
        self.output_pdf = output_pdf
        self.output_txt = output_txt
        self.output_md = output_md
        self.output_html = output_html
        self.output_json = output_json
        self.deskew = deskew
        self.clean = clean
        self.force_ocr = force_ocr
        
        # Callbacks
        self.on_progress = on_progress
        self.on_complete = on_complete
        self.on_log = on_log
        
        self._cancel_flag = threading.Event()
        self._thread: Optional[threading.Thread] = None

    def log(self, message: str):
        if self.on_log:
            self.on_log(message)

    def cancel(self):
        self._cancel_flag.set()

    def is_running(self) -> bool:
        return self._thread is not None and self._thread.is_alive()

    # ========================================================================
    # BATCH PROCESSING (Used by desktop GUI)
    # ========================================================================

    def process_batch(
        self,
        files: list[str],
        output_dir: str,
        use_wsl: bool = False,
        output_pdf: bool = True,
        output_txt: bool = True,
        output_md: bool = False,
        output_html: bool = False,
        output_json: bool = True,
        deskew: bool = True,
        clean: bool = True,
        force_ocr: bool = False,
    ):
        """Start processing a batch of files in a background thread."""
        self._cancel_flag.clear()
        # Update internal config for this batch
        self.backend = "wsl" if use_wsl else "python"
        self.output_dir = output_dir
        self.output_pdf = output_pdf
        self.output_txt = output_txt
        self.output_md = output_md
        self.output_html = output_html
        self.output_json = output_json
        self.deskew = deskew
        self.clean = clean
        self.force_ocr = force_ocr

        self._thread = threading.Thread(
            target=self._process_batch_impl,
            args=(files,),
            daemon=True,
        )
        self._thread.start()

    def _process_batch_impl(self, files: list[str]):
        os.makedirs(self.output_dir, exist_ok=True)

        for filepath in files:
            if self._cancel_flag.is_set():
                self.log("Batch cancelled by user.")
                break

            filename = os.path.basename(filepath)
            self.log(f"Starting: {filename}")

            try:
                if self.backend == "wsl":
                    success, msg = self._process_wsl(filepath)
                else:
                    success, msg = self._process_python(filepath)

                if self.on_complete:
                    # GUI expects (filename, success, message)
                    self.on_complete(filename, success, msg)

            except Exception as e:
                self.log(f"Error processing {filename}: {e}")
                if self.on_complete:
                    self.on_complete(filename, False, str(e))

    # ========================================================================
    # SINGLE FILE PROCESSING (Used by web server)
    # ========================================================================

    def process_file(self, filepath: str, on_progress=None, on_complete=None):
        """Process a single file directly."""
        if on_progress: self.on_progress = on_progress
        if on_complete: self.on_complete = on_complete
        
        try:
            if self.backend == "wsl":
                success, msg = self._process_wsl(filepath)
            else:
                success, msg = self._process_python(filepath)
            
            if self.on_complete:
                # Server expects (success, message)
                self.on_complete(success, msg)
        except Exception as e:
            if self.on_complete:
                self.on_complete(False, str(e))

    # ========================================================================
    # BACKENDS
    # ========================================================================

    def _process_python(self, filepath: str) -> tuple[bool, str]:
        """Process using pytesseract (Windows native)."""
        try:
            import pytesseract
            from pdf2image import convert_from_path
            from PIL import Image
        except ImportError as e:
            return False, f"Missing dependency: {e}"

        filename = os.path.basename(filepath)
        base_name = os.path.splitext(filename)[0]

        ext = os.path.splitext(filepath)[1].lower()
        if ext == ".pdf":
            self.log(f"Converting PDF to images: {filename}")
            try:
                images = convert_from_path(filepath, poppler_path=POPPLER_PATH)
            except Exception as e:
                return False, f"PDF conversion failed: {e}"
        elif ext in (".heic", ".heif"):
            # iPhone photo format
            if not HEIC_SUPPORTED:
                return False, "HEIC support requires pillow-heif: pip install pillow-heif"
            self.log(f"Opening iPhone photo: {filename}")
            try:
                images = [Image.open(filepath)]
            except Exception as e:
                return False, f"HEIC loading failed: {e}"
        else:
            # Standard image formats: JPG, PNG, TIFF, WEBP, etc.
            self.log(f"Opening image directly: {filename}")
            try:
                images = [Image.open(filepath)]
            except Exception as e:
                return False, f"Image loading failed: {e}"

        ocr_json_data = {
            "version": "1.0",
            "filename": filename,
            "pages": []
        }

        for i, image in enumerate(images):
            if self._cancel_flag.is_set():
                return False, "Cancelled"

            page_num = i + 1
            self.log(f"  Page {page_num}/{total_pages}")

            if self.on_progress:
                # Handle both GUI (4 args) and Server (2 args) callbacks
                try:
                    self.on_progress(filename, page_num, total_pages, "Processing")
                except TypeError:
                    pct = int((page_num / total_pages) * 100)
                    self.on_progress(pct, f"Processing page {page_num}/{total_pages}...")

            # 1. Standard text output
            text = pytesseract.image_to_string(image)
            full_text += f"\n\n--- PAGE {page_num} ---\n\n{text}"

            # 2. Coordinate data for Workbench
            if self.output_json:
                data = pytesseract.image_to_data(image, output_type=pytesseract.Output.DICT)
                page_data = {
                    "page": page_num,
                    "width": image.width,
                    "height": image.height,
                    "lines": []
                }
                
                # Group words into lines for smoother sync
                current_line = None
                last_line_id = -1
                
                for j in range(len(data['text'])):
                    # Level 5 is Word
                    if data['level'][j] == 5:
                        text_val = data['text'][j].strip()
                        if not text_val: continue
                        
                        line_id = f"{data['block_num'][j]}_{data['line_num'][j]}"
                        if line_id != last_line_id:
                            current_line = {
                                "bbox": [data['left'][j], data['top'][j], data['left'][j]+data['width'][j], data['top'][j]+data['height'][j]],
                                "text": text_val
                            }
                            page_data["lines"].append(current_line)
                            last_line_id = line_id
                        else:
                            current_line["text"] += " " + text_val
                            # Expand line bbox (right, bottom)
                            current_line["bbox"][2] = data['left'][j] + data['width'][j]
                            current_line["bbox"][3] = max(current_line["bbox"][3], data['top'][j] + data['height'][j])

                ocr_json_data["pages"].append(page_data)

        if self.output_txt:
            txt_path = os.path.join(self.output_dir, f"{base_name}.txt")
            with open(txt_path, "w", encoding="utf-8") as f:
                f.write(full_text)
            self.log(f"  Saved: {base_name}.txt")

        if self.output_md:
            md_path = os.path.join(self.output_dir, f"{base_name}.md")
            md_content = f"# OCR Result: {filename}\n\n"
            # Simple conversion of page markers to H2
            for part in full_text.split("--- PAGE "):
                if not part.strip(): continue
                lines = part.splitlines()
                if not lines: continue
                page_info = lines[0].replace(" ---", "")
                content = "\n".join(lines[1:])
                md_content += f"## Page {page_info}\n\n{content}\n\n---\n\n"
            
            with open(md_path, "w", encoding="utf-8") as f:
                f.write(md_content)
            self.log(f"  Saved: base_name.md")

        if self.output_html:
            html_path = os.path.join(self.output_dir, f"{base_name}.html")
            
            sections = []
            for part in full_text.split("--- PAGE "):
                if not part.strip(): continue
                lines = part.splitlines()
                if not lines: continue
                page_info = lines[0].replace(" ---", "").strip()
                content = "\n".join(lines[1:]).strip()
                
                section_html = f"""
        <section>
            <div class="page-header">
                <span>PHASE: TRANSCRIPTION</span>
                <span>PAGE {page_info}</span>
            </div>
            <div class="content">{content}</div>
        </section>"""
                sections.append(section_html)
            
            final_html = HTML_TEMPLATE.replace("{{TITLE}}", base_name.upper())
            final_html = final_html.replace("{{FILENAME}}", filename)
            final_html = final_html.replace("{{CONTENT}}", "\n".join(sections))
            
            with open(html_path, "w", encoding="utf-8") as f:
                f.write(final_html)
            self.log(f"  Saved: {base_name}.html")

        if self.output_json:
            json_path = os.path.join(self.output_dir, f"{base_name}.ocr.json")
            with open(json_path, "w", encoding="utf-8") as f:
                json.dump(ocr_json_data, f, indent=2)
            self.log(f"  Saved: {base_name}.ocr.json")

        if self.output_pdf:
            self.log("  Note: Searchable PDF output requires WSL mode.")

        return True, "Complete"

    def _process_wsl(self, filepath: str) -> tuple[bool, str]:
        """Process using ocrmypdf via WSL."""
        filename = os.path.basename(filepath)
        base_name = os.path.splitext(filename)[0]

        wsl_input = self._to_wsl_path(filepath)
        wsl_output_dir = self._to_wsl_path(self.output_dir)

        pdf_output = f"{wsl_output_dir}/{base_name}_searchable.pdf"
        txt_output = f"{wsl_output_dir}/{base_name}.txt" if self.output_txt else None

        cmd = ["wsl", "ocrmypdf"]
        if self.deskew: cmd.append("--deskew")
        if self.clean: cmd.append("--clean")
        if self.force_ocr: cmd.append("--force-ocr")
        if txt_output: cmd.extend(["--sidecar", txt_output])

        cmd.extend([wsl_input, pdf_output])

        self.log(f"  Running OCRmyPDF...")

        if self.on_progress:
            try:
                self.on_progress(filename, 0, 100, "OCRmyPDF running...")
            except TypeError:
                self.on_progress(10, "Starting OCRmyPDF in WSL...")

        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=3600)

            if result.returncode == 0:
                self.log(f"  Saved: {base_name}_searchable.pdf")
                if self.output_txt: self.log(f"  Saved: {base_name}.txt")
                
                # Convert to MD if requested
                if self.output_md and txt_output:
                    local_txt = os.path.join(self.output_dir, f"{base_name}.txt")
                    if os.path.exists(local_txt):
                        with open(local_txt, "r", encoding="utf-8") as f:
                            text = f.read()
                        md_path = os.path.join(self.output_dir, f"{base_name}.md")
                        with open(md_path, "w", encoding="utf-8") as f:
                            f.write(f"# OCR Result: {filename}\n\n{text}")
                        self.log(f"  Saved: {base_name}.md")

                if self.output_html and txt_output:
                    local_txt = os.path.join(self.output_dir, f"{base_name}.txt")
                    if os.path.exists(local_txt):
                        with open(local_txt, "r", encoding="utf-8") as f:
                            text = f.read()
                        
                        html_path = os.path.join(self.output_dir, f"{base_name}.html")
                        
                        # WSL output text usually doesn't have page markers unless we add them,
                        # but we'll try to handle it consistently.
                        sections = []
                        if "--- PAGE " in text:
                            parts = text.split("--- PAGE ")
                        else:
                            parts = ["1 ---\n\n" + text] # Fallback for single page/no markers
                            
                        for part in parts:
                            if not part.strip(): continue
                            lines = part.splitlines()
                            if not lines: continue
                            page_info = lines[0].replace(" ---", "").strip()
                            content = "\n".join(lines[1:]).strip()
                            
                            section_html = f"""
        <section>
            <div class="page-header">
                <span>PHASE: TRANSCRIPTION</span>
                <span>PAGE {page_info}</span>
            </div>
            <div class="content">{content}</div>
        </section>"""
                            sections.append(section_html)

                        final_html = HTML_TEMPLATE.replace("{{TITLE}}", base_name.upper())
                        final_html = final_html.replace("{{FILENAME}}", filename)
                        final_html = final_html.replace("{{CONTENT}}", "\n".join(sections))

                        with open(html_path, "w", encoding="utf-8") as f:
                            f.write(final_html)
                        self.log(f"  Saved: {base_name}.html")

                return True, "Complete"
            else:
                error_msg = result.stderr.strip() or "Unknown error"
                self.log(f"  Error: {error_msg}")
                return False, error_msg

        except Exception as e:
            self.log(f"  Error: {str(e)}")
            return False, str(e)

    def _to_wsl_path(self, windows_path: str) -> str:
        """Convert Windows path to WSL path."""
        path = os.path.abspath(windows_path)
        if path[1] == ":":
            drive = path[0].lower()
            rest = path[2:].replace("\\", "/")
            return f"/mnt/{drive}{rest}"
        return path.replace("\\", "/")
